package main

import (
	"fmt"
	"strconv"
)
func InsertStrToInt(str string)(val int){
	val,_ = strconv.Atoi(str)
	return val
}
	func ConvertArrayStrToInt(str_ary []string)(int_ary []int){
	int_ary = make([]int, 0, len(str_ary))
	for _,str := range str_ary{
		int_ary = append(int_ary, InsertStrToInt(str))
	}
	return
}

// 次の値を得るビット操作
func getNext(n int)int{
	// c0とc1を計算
	c  := n
	c0 := 0
	c1 := 0

	// n=13948(10)=11011001111100(2) → 110110011111[00](2)
	// 上記の例の[00]を取得
	for ((c&1) == 0) && (c != 0){
		c0++
		c >>= 1
	}

	// n=13948(10)=11011001111100(2) → 1101100[11111]00(2)
	// 上記の例の[11111]を取得
	for (c&1)==1{
		c1++
		c >>= 1
	}

	// エラー:もし n== 11..1100...00なら、
	//       1が同じ個数でより大きな数は存在しない
	if (c0+c1 == 31 || c0+c1 == 0){
		return -1
	}

	// 最下位ビットから連続する0以外の最も右の0の場所
	// n=13948(10)=11011001111100(2) → 110110[0]1111100(2) 7ビット目
	p := c0+c1

	// pのビットを反転する
	// 例では7ビット目
	//           10000000
	// n   11011001111100
	//-------------------
	// OR  11011011111100
	n |= (1<<p)

	// pより右にあるビットをクリアする
	// 10000000 (-1)→ 01111111 (^)→ 11111110000000
	//     11111110000000
	// n   11011011111100
	//-------------------
	// AND 11011010000000
	n &= ^((1<<p)-1)

	// (c1-1)個の1を右に挿入する
	// (c1-1)個=4 → 10000 (-1)→ 01111
	//              01111
	// n   11011010000000
	//-------------------
	// OR  11011010001111
	n |= (1<<(c1-1))-1

	return n
}

// 前の値を得るビット操作
func getPrev(n int)int{
	// c0とc1を計算
	tmp:= n
	c0 := 0
	c1 := 0

	// c1取得
	// n=10115(10)=10011110000011(2) → 100111100000[11](2)
	// 上記の例の[11]を取得
	for tmp & 1 == 1{
		c1++
		tmp >>= 1
	}
	if tmp==0 {
		return -1
	}

	// n=10115(10)=10011110000011(2) → 1001111[00000]11(2)
	// 上記の例の[00000]を取得
	for ((tmp&1)==0)&& (tmp!=0){
		c0++
		tmp >>= 1
	}

	// 最下位ビットから連続する1以外の最も右の0の場所
	// n=10115(10)=10011110000011(2) → 100111[1]0000011(2) 7ビット目
	p := c0+c1

	// pビット以下をクリアする
	// 例では7ビット目
	//          100000000
	// n   10011110000011
	//-------------------
	// AND 10011100000000
	n &= ((^0)<<(p+1))

	// (c1+1)個の列
	// c1=2 1<<(c1+1)→ 1000 (-1)→ 111
	mask := (1<<(c1+1))-1

	// c0=5 (c0-1)→ 4
	// mask       1110000
	// n   10011100000000
	//-------------------
	// OR  10011101110000
	n |= mask << (c0-1)

	return n
}

func getNextArith(n int)int{
		// c0とc1を計算
		c  := n
		c0 := 0
		c1 := 0

		for ((c&1) == 0) && (c != 0){
			c0++
			c >>= 1
		}

		for (c&1)==1{
			c1++
			c >>= 1
		}

	return n+(1<<c0)+(1<<(c1-1))-1
}
func getPrevArith(n int)int{
	// c0とc1を計算
	tmp:= n
	c0 := 0
	c1 := 0

	// c1取得
	// n=10115(10)=10011110000011(2) → 100111100000[11](2)
	// 上記の例の[11]を取得
	for tmp & 1 == 1{
		c1++
		tmp >>= 1
	}
	if tmp==0 {
		return -1
	}

	// n=10115(10)=10011110000011(2) → 1001111[00000]11(2)
	// 上記の例の[00000]を取得
	for ((tmp&1)==0)&& (tmp!=0){
		c0++
		tmp >>= 1
	}
	return n-(1<<c1)-(1<<(c0-1))+1
}

func main() {
	// 入力:n=13948(10)=11011001111100(2)
	// 出力:n=13967(10)=11011010001111(2)
	n1:=13948
	fmt.Println(getNext(n1))
	fmt.Println(getNextArith(n1))

	// 入力:n=10115(10)=10011110000011(2)
	// 出力:n=10096(10)=10011101110000(2)
	n2:=10115
	fmt.Println(getPrev(n2))
	fmt.Println(getPrevArith(n2))


}
